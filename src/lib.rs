use std::convert::TryInto;

use lv2::{prelude::*, lv2_core::plugin};

mod synth;
use synth::{ThreeOsc, oscillator::OscWave, filter::{Filter, FilterType}};
use wmidi::MidiMessage;

/// This struct must match the output file `portstruct.rs` generated by `build.rs`, and it must be kept up-to-date manually. 
/// I tried to automate it with `include!(concat!(env!("OUT_DIR"), "/portstruct.rs"));` but apparently it didn't work with derive macro expansion.
#[derive(PortCollection)]
struct Ports {
    midi: InputPort<AtomPort>,
    out_l: OutputPort<Audio>,
    out_r: OutputPort<Audio>,
    osc1_amp: InputPort<Control>,
    osc1_semitone: InputPort<Control>,
    osc1_octave: InputPort<Control>,
    osc1_multiplier: InputPort<Control>,
    osc1_wave: InputPort<Control>,
    osc1_pm: InputPort<Control>,
    osc1_fm: InputPort<Control>,
    osc1_voices: InputPort<Control>,
    osc1_super_detune: InputPort<Control>,
    osc1_phase: InputPort<Control>,
    osc1_phase_rand: InputPort<Control>,
    osc2_amp: InputPort<Control>,
    osc2_semitone: InputPort<Control>,
    osc2_octave: InputPort<Control>,
    osc2_multiplier: InputPort<Control>,
    osc2_wave: InputPort<Control>,
    osc2_pm: InputPort<Control>,
    osc2_fm: InputPort<Control>,
    osc2_voices: InputPort<Control>,
    osc2_super_detune: InputPort<Control>,
    osc2_phase: InputPort<Control>,
    osc2_phase_rand: InputPort<Control>,
    fil1_model: InputPort<Control>,
    fil1_mode: InputPort<Control>,
    fil1_cutoff: InputPort<Control>,
    fil1_resonance: InputPort<Control>,
    fil1_keytrack: InputPort<Control>,
    fil1_env_amount: InputPort<Control>,
    fil1_attack: InputPort<Control>,
    fil1_decay: InputPort<Control>,
    fil1_sustain: InputPort<Control>,
    fil1_release: InputPort<Control>,
    fil1_slope: InputPort<Control>,
    vol_attack: InputPort<Control>,
    vol_decay: InputPort<Control>,
    vol_sustain: InputPort<Control>,
    vol_release: InputPort<Control>,
    vol_slope: InputPort<Control>,
    output_gain: InputPort<Control>,
    global_pitch: InputPort<Control>,
    bend_range: InputPort<Control>,
}

#[derive(FeatureCollection)]
pub struct Features<'a> {
    map: LV2Map<'a>,
}

#[derive(URIDCollection)]
pub struct URIDs {
    atom: AtomURIDCollection,
    midi: MidiURIDCollection,
    unit: UnitURIDCollection,
}

#[uri("https://github.com/Madadog/three_osc")]
struct SynthLv2 {
    synth: ThreeOsc,
    urids: URIDs,
}

// Every plugin struct implements the `Plugin` trait. This trait contains both the methods that are called by the hosting application and the collection types for the ports and the used host features. This plugin does not use additional host features and therefore, we set both feature collection types to `()`. Other plugins may define separate structs with their required and optional features and set it here.
impl Plugin for SynthLv2 {
    type Ports = Ports;

    type InitFeatures = Features<'static>;
    type AudioFeatures = ();

    // The `new` method is called by the plugin backend when it creates a new plugin instance. The host passes the plugin URI, sample rate, and bundle path for plugins that need to load additional resources (e.g. waveforms). The features parameter contains host-provided features defined in LV2 extensions, but this simple plugin does not use any. This method is in the “instantiation” threading class, so no other methods on this instance will be called concurrently with it.
    fn new(plugin_info: &PluginInfo, features: &mut Features<'static>) -> Option<Self> {
        println!("Sample rate was: {}", plugin_info.sample_rate());
        Some(Self {
            synth: ThreeOsc::new(plugin_info.sample_rate()),
            urids: features.map.populate_collection()?,
        })
    }
    // The `run()` method is the main process function of the plugin. It processes a block of audio in the audio context. Since this plugin is `lv2:hardRTCapable`, `run()` must be real-time safe, so blocking (e.g. with a mutex) or memory allocation are not allowed.
    fn run(&mut self, ports: &mut Ports, _features: &mut (), _sample_count: u32) {
        let coef = if *(ports.output_gain) > -90.0 {
            10.0_f32.powf(*(ports.output_gain) * 0.05)
        } else {
            0.0
        };
        self.synth.bend_range = *ports.bend_range;

        // adjust master gain envelope
        self.synth.gain_envelope.attack_time = *ports.vol_attack;
        self.synth.gain_envelope.decay_time = *ports.vol_decay;
        self.synth.gain_envelope.sustain_level = *ports.vol_sustain;
        self.synth.gain_envelope.release_time = *ports.vol_release;
        self.synth.gain_envelope.slope = 2.0_f32.powf(*ports.vol_slope);

        self.synth.filter_controller.envelope_amount = *ports.fil1_env_amount * 22000.0;
        self.synth.filter_controller.keytrack = *ports.fil1_keytrack;
        self.synth.filter_controller.cutoff_envelope.attack_time = *ports.fil1_attack;
        self.synth.filter_controller.cutoff_envelope.decay_time = *ports.fil1_decay;
        self.synth.filter_controller.cutoff_envelope.sustain_level = *ports.fil1_sustain;
        self.synth.filter_controller.cutoff_envelope.release_time = *ports.fil1_release;
        self.synth.filter_controller.cutoff_envelope.slope = 2.0_f32.powf(*ports.fil1_slope);
        self.synth.filter_controller.cutoff = *ports.fil1_cutoff;
        self.synth.filter_controller.resonance = *ports.fil1_resonance;
        self.synth.filter_controller.mode = match *ports.fil1_mode {
            x if x < 1.0 => {FilterType::Lowpass},
            x if x < 2.0 => {FilterType::Bandpass},
            x if x <= 3.0 => {FilterType::Highpass},
            _ => {panic!("You messed up")}
        };

        //self.synth.gain_envelope.limits();

        // apply oscillator ports
        // ... TODO: write a macro for all this
        {
            // osc1
            self.synth.oscillators[0].amp = *ports.osc1_amp / 100.0;
            self.synth.oscillators[0].semitone = *ports.osc1_semitone + *ports.global_pitch;
            self.synth.oscillators[0].octave = *ports.osc1_octave as i32;
            self.synth.oscillators[0].multiplier = if ports.osc1_multiplier.is_sign_positive() {
                1.0 + *ports.osc1_multiplier
            } else {
                1.0 / (1.0 - *ports.osc1_multiplier)
            };
            self.synth.oscillators[0].voice_count = *ports.osc1_voices as u8;
            self.synth.oscillators[0].voices_detune = (*ports.osc1_super_detune / 100.0).powi(3);
            self.synth.oscillators[0].phase = *ports.osc1_phase;
            self.synth.oscillators[0].phase_rand = *ports.osc1_phase_rand;
            self.synth.oscillators[0].wave = match *ports.osc1_wave {
                x if x < 1.0 => OscWave::Sine,
                x if x < 2.0 => OscWave::Tri,
                x if x < 3.0 => OscWave::Saw,
                x if x < 4.0 => OscWave::Exp,
                x if x < 5.0 => OscWave::Square,
                x if x < 6.0 => OscWave::PulseQuarter,
                x if x < 7.0 => OscWave::PulseEighth,
                _ => OscWave::Sine,
            };
            self.synth.osc1_pm = *ports.osc1_pm;
            self.synth.osc1_fm = *ports.osc1_fm;
    
            // osc2
            self.synth.oscillators[1].amp = *ports.osc2_amp / 100.0;
            self.synth.oscillators[1].semitone = *ports.osc2_semitone + *ports.global_pitch;
            self.synth.oscillators[1].octave = *ports.osc2_octave as i32;
            self.synth.oscillators[1].multiplier = if ports.osc2_multiplier.is_sign_positive() {
                1.0 + *ports.osc2_multiplier
            } else {
                1.0 / (1.0 - *ports.osc2_multiplier)
            };
            self.synth.oscillators[1].voice_count = *ports.osc2_voices as u8;
            self.synth.oscillators[1].voices_detune = (*ports.osc2_super_detune / 100.0).powi(3);
            self.synth.oscillators[1].phase = *ports.osc2_phase;
            self.synth.oscillators[1].phase_rand = *ports.osc2_phase_rand;
            self.synth.oscillators[1].wave = match *ports.osc2_wave {
                x if x < 1.0 => OscWave::Sine,
                x if x < 2.0 => OscWave::Tri,
                x if x < 3.0 => OscWave::Saw,
                x if x < 4.0 => OscWave::Exp,
                x if x < 5.0 => OscWave::Square,
                x if x < 6.0 => OscWave::PulseQuarter,
                x if x < 7.0 => OscWave::PulseEighth,
                _ => OscWave::Sine,
            };

        }

        // self.synth.filter.a2 = *ports.fil1_resonance;
        // self.synth.filter.set_params(self.synth.sample_rate as f32, *ports.fil1_cutoff, *ports.fil1_resonance);
        // self.synth.filter.set_cutoff(*ports.fil1_cutoff);
        // self.synth.filter.set_resonance(*ports.fil1_resonance);
        // self.synth.filter.b0 = *ports.fil1_mode;
        // self.synth.filter.b1 = *ports.fil1_slope;
        // self.synth.filter.b2 = *ports.fil1_feedback0_1;
        // self.synth.filter.feedback = *ports.fil1_feedback1_0;

        
        let control_sequence = ports
            .midi
            .read(self.urids.atom.sequence, self.urids.unit.beat)
            .unwrap();

        for (timestamp, message) in control_sequence {
            let timestamp: usize = if let Some(timestamp) = timestamp.as_frames() {
                timestamp as usize
            } else {
                continue;
            };

            let message = if let Some(message) = message.read(self.urids.midi.wmidi, ()) {
                message
            } else {
                continue;
            };

            match message {
                MidiMessage::NoteOn(_, note, velocity) => {
                    let id: u8 = note.into();
                    let velocity: u8 = velocity.into();
                    self.synth.note_on(id, velocity);
                    println!("received note_on {note:?}");
                    println!("there are {} voices...", self.synth.voices.len());
                },
                MidiMessage::NoteOff(_, note, velocity) => {
                    let id: u8 = note.into();
                    let velocity: u8 = velocity.into();
                    self.synth.note_off(id, velocity);
                    println!("received note_off {note:?}");
                    println!("there are {} voices...", self.synth.voices.len());
                },
                MidiMessage::ProgramChange(_, program) => {

                },
                MidiMessage::PitchBendChange(_, bend) => {
                    self.synth.pitch_bend(bend.into());
                },
                _ => (),
            }
        }

        // change output volume
        self.synth.output_volume = coef;

        // run synthesiser
        self.synth.run(ports.out_l.iter_mut().zip(ports.out_r.iter_mut()));
        

    }
}
// The `lv2_descriptors` macro creates the entry point to the plugin library. It takes structs that implement `Plugin` and exposes them. The host will load the library and call a generated function to find all the plugins defined in the library.
lv2_descriptors!(SynthLv2);
